<body bgcolor=#333638 style="width:724px;margin:auto;font:16px/20px sans-serif;color:#FFF">
<div style="padding:10px;height:15px">Score <b id=s>0</b></div>
<canvas id="a"></canvas>
<script>
// Tiles
var titles = ['Void'];

var TILE_EARTH = parseInt('00001', 2);
var TILE_WATER = parseInt('00010', 2);
var TILE_AIR   = parseInt('00100', 2);
var TILE_FIRE  = parseInt('01000', 2);
var TILE_QUINTESSENCE = parseInt('10000', 2);

titles[TILE_AIR] = 'Air';
titles[TILE_FIRE] = 'Fire';
titles[TILE_EARTH] = 'Earth';
titles[TILE_WATER] = 'Water';

titles[TILE_AIR + TILE_FIRE] = 'Phlogiston';
titles[TILE_AIR + TILE_EARTH] = 'Sand';
titles[TILE_AIR + TILE_WATER] = 'Rain';
titles[TILE_FIRE + TILE_EARTH] = 'Brimstone';
titles[TILE_FIRE + TILE_WATER] = 'Alcohol';
titles[TILE_EARTH + TILE_WATER] = 'Mud';

titles[TILE_AIR + TILE_FIRE + TILE_EARTH] = 'Diamond';
titles[TILE_AIR + TILE_FIRE + TILE_WATER] = 'Lightning';
titles[TILE_AIR + TILE_EARTH + TILE_WATER] = 'Golem';
titles[TILE_FIRE + TILE_EARTH + TILE_WATER] = 'Oil';

titles[TILE_AIR + TILE_FIRE + TILE_EARTH + TILE_WATER] = 'Life';

titles[TILE_QUINTESSENCE] = 'Quintessence';

titles[TILE_AIR + TILE_FIRE + TILE_EARTH + TILE_WATER + TILE_QUINTESSENCE] = 'Harmony';


var tiles = []; // Tile images
var hoveredTiles = []; // Tile images

var c=a.getContext('2d');

for (var code=64; code--; ){
	a.width=80;
	a.height=80;
	var imageData=c.createImageData(80,80);
	for (var idx=6400; idx--; ){
		var y = (idx / 80 | 0) - 39.5;
		var x = idx % 80 - 39.5;

		var value = Math.random() * 16 | 160; // 0xA0...0xAF integer
		value -= (x*x*x)/1200;
		value -= (y*y*y)/1200;

		imageData.data[idx*4] = value + (code == TILE_FIRE || code == TILE_AIR) * 20;
		imageData.data[idx*4+1] = value - 5 + (code == TILE_EARTH || code == TILE_AIR) * 20;
		imageData.data[idx*4+2] = value - 20 + (code == TILE_WATER) * 20;
		imageData.data[idx*4+3] = 9000 - (x*x+y*y)*3;
	}
	for (var activityState = 2; activityState--; ){
		c.putImageData(imageData, 0, 0);

		c.globalCompositeOperation = 'source-atop';
		for (var drawPosition = 6; --drawPosition;){ // Note the pre-increment. drawPosition is in range 5..1
			c.save();

			c.translate(
				drawPosition & 4 && (5 - drawPosition) * 2 - 1,
				drawPosition & 2 && (3 - drawPosition) * 2 - 1
			);

			c.strokeStyle = c.fillStyle = drawPosition & 1 ? '#000' : '#FFF';
			c.globalAlpha = drawPosition ^ 1 ? 0.3 : activityState || .7;

			c.textAlign = 'center';
			c.fillText([titles[code]], 40, 70);

			if (activityState && drawPosition == 1){
				c.strokeStyle = '#CCC';
			}

			// Draw icons
			c.beginPath();
			c.lineWidth = 2;
			if (code == 1){ // Earth
				c.moveTo(17, 31);
				c.bezierCurveTo(
					22, 24,
					32, 24,
					32, 31
				);
				c.bezierCurveTo(
					33, 21,
					47, 21,
					49, 31
				);
				c.bezierCurveTo(
					51, 28,
					56, 24,
					63, 31
				);
				c.moveTo(18, 39);
				c.lineTo(62, 39);
				c.moveTo(18, 48);
				c.lineTo(62, 48);
			}
			if (code == 2){ // Water
				c.moveTo(20, 45);
				c.bezierCurveTo(
					40, 60,
					40, 30,
					60, 45
				);
				c.moveTo(20, 35);
				c.bezierCurveTo(
					40, 50,
					40, 20,
					60, 35
				);
				c.moveTo(20, 25);
				c.bezierCurveTo(
					40, 40,
					40, 10,
					60, 25
				);
			}
			if (code == 3) { // Mud
				c.moveTo(26, 40);
				c.bezierCurveTo(
					11, 40,
					16, 55,
					46, 45
				);
				c.bezierCurveTo(
					66, 45,
					66, 40,
					56, 40
				);
				c.moveTo(53, 35);
				c.arc(49, 35, 4, 0, Math.PI * 2, false);
				c.moveTo(40, 30);
				c.arc(33, 30, 7, 0, Math.PI * 2, false)
			}
			if (code == 4) { // Air
				c.moveTo(20, 35);
				c.bezierCurveTo(
					20, 32,
					60, 38,
					60, 35
				);
				c.moveTo(20, 27);
				c.bezierCurveTo(
					60, 27,
					65, 17,
					50, 17
				);
				c.moveTo(20, 43);
				c.bezierCurveTo(
					60, 43,
					65, 53,
					50, 53
				);
			}
			if (code == 5){ // Sand
				c.moveTo(20, 50);

				c.bezierCurveTo(
					35, 10,
					35, 10,
					50, 50
				);

				c.bezierCurveTo(
					50, 50,
					50, 55,
					35, 55
				);

				c.moveTo(50, 35);
				c.bezierCurveTo(
					55, 25,
					65, 50,
					65, 50
				);
			}
			if (code == 6){ // Rain
				c.moveTo(32, 25);
				c.bezierCurveTo(
					20, 20,
					15, 38,
					20, 38
				);
				c.lineTo(60, 38);
				c.bezierCurveTo(
					65, 38,
					63, 8,
					45, 19
				);
				c.moveTo(48, 27);
				c.bezierCurveTo(
					48, 17,
					32, 23,
					32, 30
				);
				c.moveTo(32, 42);
				c.lineTo(28, 51);

				c.moveTo(42, 42);
				c.lineTo(37, 53);

				c.moveTo(52, 42);
				c.lineTo(48, 51);

			}
			if (code == 7) { // Golem
				c.moveTo(20, 55);
				c.bezierCurveTo(
					20, 35,
					25, 40,
					30, 35
				);
				c.bezierCurveTo(
					38, 30,
					25, 20,
					40, 20
				);

				c.bezierCurveTo(
					55, 20,
					42, 30,
					50, 35
				);
				c.bezierCurveTo(
					55, 40,
					60, 35,
					60, 55
				);

				c.moveTo(31, 55);
				c.bezierCurveTo(
					31, 45,
					28, 46,
					27, 46
				);

				c.moveTo(49, 55);
				c.bezierCurveTo(
					49, 45,
					52, 46,
					53, 46
				);
			}
			if (code == 8){ // Fire
				c.moveTo(25, 40);
				c.bezierCurveTo(
					25, 60,
					55, 60,
					55, 40
				);
				c.bezierCurveTo(
					55, 30,
					40, 25,
					40, 15
				);
				c.bezierCurveTo(
					30, 25,
					45, 40,
					40, 40
				);
			}
			if (code == 9){ // Sulfur/Brimstone
				c.moveTo(33, 23);
				c.lineTo(42, 27);
				c.lineTo(45, 58);
				c.lineTo(20, 43);
				c.lineTo(30, 20);
				c.lineTo(42, 14);
				c.lineTo(55, 20);
				c.lineTo(68, 47);
				c.lineTo(50, 55);
			}
			if (code == 10){ // Alcohol
				c.moveTo(32, 17);
				c.bezierCurveTo(
					38, 17,
					37, 17,
					37, 35
				);
				c.bezierCurveTo(
					20, 47,
					15, 52,
					40, 52
				);
				c.bezierCurveTo(
					65, 52,
					60, 47,
					43, 35
				);
				c.bezierCurveTo(
					43, 17,
					42, 17,
					48, 17
				)
			}
			if (code == 11){ // Oil. Barrel of oil, or lantern - pick yourself
				c.moveTo(25, 18);
				c.bezierCurveTo(
					25, 10,
					55, 10,
					55, 18
				);
				c.bezierCurveTo(
					55, 26,
					25, 26,
					25, 18
				);
				c.moveTo(55, 48);
				c.bezierCurveTo(
					55, 56,
					25, 56,
					25, 48
				);
				c.moveTo(27, 47);
				c.lineTo(27, 24);
				c.moveTo(53, 47);
				c.lineTo(53, 24);

				c.moveTo(40, 30);
				c.bezierCurveTo(
					30, 50,
					50, 50,
					40, 30
				);
			}
			if (code == 12){ // Phlogiston
				c.moveTo(37, 10);
				c.bezierCurveTo(
					47, 20,
					17, 35,
					37, 45
				)
				c.moveTo(43, 54);
				c.bezierCurveTo(
					33, 44,
					63, 29,
					43, 19
				)
			}
			if (code == 13){ // Diamond
				c.moveTo(48, 30);
				c.lineTo(32, 30);
				c.lineTo(20, 27);
				c.lineTo(30, 17);
				c.lineTo(50, 17);
				c.lineTo(60, 27);
				c.lineTo(40, 52);
				c.lineTo(23, 32);
			}
			if (code == 14){ // Lightning
				c.moveTo(35, 13);
				c.lineTo(30, 33);
				c.lineTo(40, 35);
				c.lineTo(31, 51);
				c.lineTo(55, 31);
				c.lineTo(42, 28);
				c.lineTo(50, 15);
				c.lineTo(40, 14);
			}
			if (code == 15) { // Life
				c.moveTo(43, 19);
				c.bezierCurveTo(
					48, 13,
					55, 13,
					60, 18
				);
				c.bezierCurveTo(
					75, 33,
					40, 53,
					40, 53
				);
				c.bezierCurveTo(
					40, 53,
					5, 33,
					20, 18
				);
				c.bezierCurveTo(
					40, 8,
					45, 31,
					45, 35
				);
			}
			if (code == 16) { // Quintessence
				c.arc(40, 40, 23, 2.5, 6.9, false);
			}

			c.stroke();


			// Draw elelment hints
			if (code & 16){
				c.beginPath();
				c.arc(40, 40, 8, 0, Math.PI * 2, false);
				if (drawPosition == 1 && code != 31){
					c.fillStyle = '#FFF';
				}
				c.fill();
			}

			for (var bit = 4; bit--; ){
				// Draw special Q tiles
				c.beginPath();
				if (code > 16 && code < 31){
					if (bit & 1 ? code & TILE_AIR : code & TILE_WATER){
						c.moveTo(40, 8);
						c.bezierCurveTo(
							48, 33,
							32, 33,
							40, 8
						);
					}
					if (code & TILE_FIRE) {
						c.moveTo(25, 25);
						c.bezierCurveTo(
							25, 40,
							40, 30,
							25, 25
						);
					}
					if (code & TILE_EARTH){
						c.moveTo(11, 31);
						c.bezierCurveTo(
							7, 27,
							27, 7,
							31, 11
						);
						c.lineTo(11, 31)
					}
				}
				c.stroke();

				if (code & (1<<bit)){
					c.beginPath();
					c.moveTo(0,0);
					c.lineTo(0,35);
					c.bezierCurveTo(10,35,-4,5,12,12);
					c.bezierCurveTo(5,-4,35,10,35,0);
					if (drawPosition == 1 && code != 31){
						c.fillStyle = ['#0B0', '#00C', '#DD0', '#C00'][bit];
					}
					c.fill();
				}
				c.translate(40, 40);
				c.rotate(Math.PI / 2);
				c.translate(-40, -40);
			}
			c.restore();
		}
		var image = new Image();
		image.src = a.toDataURL();
		if (activityState){
			hoveredTiles[code] = image;
		} else {
			tiles[code] = image;
		}
	}
}

// Draw bg
a.width=724;
a.height=724;
var TILE_WIDTH = 80;
var CELL_PADDING = 2;
var CELL_BORDER = 1;
var CELL_MARGIN = 4;
var cell = CELL_PADDING + TILE_WIDTH + CELL_PADDING;
var cellInterval = CELL_BORDER + cell + CELL_BORDER + CELL_MARGIN;

var size = 8 * (CELL_BORDER + cell + CELL_BORDER) + (8+1) * CELL_MARGIN;

var imageData=c.createImageData(size,size);
for (var idx=size * size; idx--; ){
	var xPhase = idx % size % cellInterval - CELL_MARGIN;
	var yPhase = (idx / size % cellInterval | 0) - CELL_MARGIN;
	 // Board acts like background, it should be darker and more bluish
	var value = Math.random() * 12 | 96; // 0x60...0x6B integer

	if (xPhase >= 0 & yPhase >= 0){
		value -= 20;
		if (xPhase == 0 || yPhase == 0){
			value -= 30;
		}
		if (xPhase == CELL_BORDER + cell || yPhase == CELL_BORDER + cell){
			value += 30;
		}
	}

	imageData.data[idx*4] = value;
	imageData.data[idx*4+1] = value+=3;
	imageData.data[idx*4+2] = value+=5;
	imageData.data[idx*4+3] = 255;
}
c.putImageData(imageData, 0, 0);

a.style.background = 'url(' + a.toDataURL() + ')'; // We don't need to repaint this


function getNewTileIndex(){
	return [1,2,4,8][Math.random() * 4 | 0];
}

var blockingAnimations = [0]; // Anything, just to ensure field filling loop works for the first time
var nonblockingAnimations = [];

var score = 0;

function getTileGeneration(tile){
	return tile.toString(2).replace(/0/g,'').length;
}

function addScore(increment, idx){
	if (gameStarted){
		score += increment;
		s.innerHTML = score;
		nonblockingAnimations.push({
			'fn': animationScore,
			'affectedTiles': [],
			'timestamp': +new Date,
			'increment': increment,
			'idx': idx
		})
	}
}

var field = [];
var gameStarted = 0;
// Fill field ensuring there's no triples
for (;blockingAnimations.length;){ // repeat until there's no blocking animations (sweep/gravity did nothing)
	for (var i=64; i--; ){
		// Push random tiles
		field[i]=getNewTileIndex();
	}

	// Cleanup all animations
	blockingAnimations = [];
	nonblockingAnimations = [];
	// Fast forward sweep/gravity
	sweep();
	gravity();
}
var gameStarted = 1;

var hoveredCoords = 0; // Something falsy, but not null/undefined
var dragStartCoords = 0; // Something falsy, but not null/undefined

function extractCoords(e){
	var a = [
		(1/e.offsetX) ? e.offsetX : e.layerX, // [0] - Relative X
		(1/e.offsetX) ? e.offsetY : e.layerY  // [1] - Relative Y
	];
	a = a.concat(a.map(getTileByCoord)); // [2], [3] - tile X/Y
	a[4] = a[3]*8 + a[2];
	return a;
}

function getTileByCoord(coord){
	coord = (coord - 2) / 90 | 0;
	if (coord & 8) return; // if (coord == -1 || coord == 8) return undefined (-> NaN)
	return coord;
}

// UI
a.onmousemove = function(e){
	var coords = extractCoords(e);
	// Request repaint only if hovered tile changed
	// Keep in mind, coords[4] may be `undefined`!
	hoveredCoords[4] == coords[4] || invalidate();
	hoveredCoords = coords;
	if (dragStartCoords && !blockingAnimations[0]){
		var dx = hoveredCoords[0] - dragStartCoords[0];
		var dy = hoveredCoords[1] - dragStartCoords[1];
		if (dx*dx + dy*dy > 5000){ // Threshold
			var direction = +(dx/dy * dx/dy < 1); // 0 if x, 1 if y
			var sign = hoveredCoords[direction] - dragStartCoords[direction] > 0 ? 1 : -1
			var newTileCoord = dragStartCoords[2+direction] + sign;
			var failed = 0;
			if (newTileCoord & 8){ // == 0 or == 8
				failed = 1;
			}
			var idx = (direction ? newTileCoord : dragStartCoords[3]) * 8 + (direction ? dragStartCoords[2] : newTileCoord);
			if (field[idx] & field[dragStartCoords[4]]){
				failed = 1;
			}
			console.log('Drag from', dragStartCoords[4], 'to', idx, 'failed: ', !!failed);

			if (failed){
				nonblockingAnimations.push({
					'fn': animationMergeFailed,
					'affectedTiles': [dragStartCoords[4]],
					'timestamp': +new Date,
					'direction': direction,
					'sign': sign
				});
			} else {
				blockingAnimations = [{
					'fn': animationMerge, // Type of animation
					'affectedTiles': [idx, dragStartCoords[4]], // Tiles that are affected (always an array). To, from
					'timestamp': +new Date, // Start of the animation
					'tiles': [field[idx], field[dragStartCoords[4]]]
				}];

				// Changing field!
				field[idx] = field[idx] | field[dragStartCoords[4]];
				field[dragStartCoords[4]] = 0;
				//
				recalcState = recalcState || [];

				addScore(getTileGeneration(field[idx]) * 10, idx);

			}
			invalidate();
			dragStartCoords = 0;
		}
	}
}
a.onmouseout = function(e){ // e argument is unused
	hoveredCoords = 0;
	invalidate();
}
a.onmousedown = function(e){
	e.preventDefault();
	if (!blockingAnimations[0]){
		var coords = extractCoords(e);
		dragStartCoords[4] == coords[4] || invalidate();
		dragStartCoords = coords;
	}
}
a.onmouseup = function(e){  // e argument is unused
	dragStartCoords = 0;
	invalidate();
}



function animationFalling(descriptor){
	var x = descriptor.affectedTiles % 8; // Affected tiles array contains only one value, it is safe do do this trick
	var yStart = descriptor.fallFrom;
	var yEnd = descriptor.affectedTiles / 8 | 0;
	var timeElapsed = new Date - descriptor.timestamp;
	var y = (timeElapsed * timeElapsed) / 1e5 + yStart; // Tile moves with acceleration
	if (y < yEnd){
		c.drawImage(tiles[field[descriptor.affectedTiles]], x * 90 + 7, y * 90 + 7);
		return 1;
	}
}

function animationMerge(descriptor){
	var animationStage = (new Date - descriptor.timestamp) / 300;
	if (animationStage < 2){
		var dstX = (descriptor.affectedTiles[0] % 8);
		var dstY = (descriptor.affectedTiles[0] / 8 | 0);

		c.save();
		c.fillStyle = '#FFF';
		if (animationStage < 1){
			var animationDistance = Math.cos(animationStage * Math.PI / 2)
			var dX = (descriptor.affectedTiles[1] % 8) - dstX;
			var dY = (descriptor.affectedTiles[1] / 8 | 0) - dstY;
			var srcX = dstX + dX * animationDistance;
			var srcY = dstY + dY * animationDistance;

			c.drawImage(hoveredTiles[descriptor.tiles[0]], dstX * 90 + 7, dstY * 90 + 7);
			c.drawImage(hoveredTiles[descriptor.tiles[1]], srcX * 90 + 7, srcY * 90 + 7);


			var leftX = Math.max(dstX, srcX) * 90 + 7;
			var topY = Math.max(dstY, srcY) * 90 + 7;
			var rightX = Math.min(dstX, srcX) * 90 + 7 + 80;
			var bottomY = Math.min(dstY, srcY) * 90 + 7 + 80;

			if (rightX > leftX && bottomY > topY){
				c.globalCompositeOperation = 'source-atop';
				c.fillRect(
					leftX,
					topY,
					rightX - leftX,
					bottomY - topY
				)
			}
		} else {
			c.drawImage(hoveredTiles[field[descriptor.affectedTiles[0]]], dstX * 90 + 7, dstY * 90 + 7);
			c.globalCompositeOperation = 'source-atop';
			c.globalAlpha = 2 - animationStage;
			c.fillRect(dstX * 90 + 7, dstY * 90 + 7, 80, 80);
		}
		c.restore();
		return 1;
	}
}

function animationMergeFailed(descriptor){
	console.log('animationMergeFailed', descriptor.direction, descriptor.sign)
	var animationStage = (new Date - descriptor.timestamp) / 1000;

	if (animationStage < 1){
		var shift = Math.cos(animationStage * 15) * .18 * (1-animationStage);
		var x = descriptor.affectedTiles[0] % 8 + shift * descriptor.sign * (1 - descriptor.direction);
		var y = (descriptor.affectedTiles[0] / 8 | 0) + shift * descriptor.sign * descriptor.direction;
		var tilesArray = descriptor.affectedTiles[0] == hoveredCoords[4] ? hoveredTiles : tiles;
		c.drawImage(tilesArray[field[descriptor.affectedTiles[0]]], x * 90 + 7, y * 90 + 7);
		return 1;
	}
}

function animationDisappear(descriptor){
	var alpha = 1 - (new Date - descriptor.timestamp) / 300;
	if (alpha > 0){
		if (descriptor.q){
			var x = descriptor.q % 8;
			var y = descriptor.q / 8 | 0;
			c.drawImage(hoveredTiles[16], x * 90 + 7, y * 90 + 7);
		}
		c.save();
		c.globalAlpha = alpha;
		for (var i=descriptor.affectedTiles.length; i--; ){
			var x = descriptor.affectedTiles[i] % 8;
			var y = descriptor.affectedTiles[i] / 8 | 0;
			c.drawImage(hoveredTiles[descriptor.tile], x * 90 + 7, y * 90 + 7);
		}
		c.restore();
		return 1;
	}
}

function animationExplosion(descriptor){
	var animationStage = (new Date - descriptor.timestamp) / 1000;
	if (animationStage < 1){
		var tile = descriptor.field[descriptor.affectedTiles[0]];
		if (tile == 31){
			var idx = descriptor.affectedTiles[0];
			var x = idx % 8;
			var y = idx / 8 | 0;
			c.save();
			c.globalAlpha = 1 - animationStage;
			c.fillStyle = '#FFF';
			c.fillRect(0,0,1e3,1e3);
			c.globalAlpha = Math.min((1 - animationStage) * 2, 1);
			c.drawImage(hoveredTiles[descriptor.field[idx]], x * 90 + 7, y * 90 + 7);
			c.restore();
		} else {
			for (var i=descriptor.affectedTiles.length; i--; ){
				c.save();
				var idx = descriptor.affectedTiles[i];
				var x = idx % 8;
				var y = idx / 8 | 0;
				if (!i){
					c.globalAlpha = Math.max((.7 - animationStage) * .7, 0);
					if (tile & TILE_FIRE){
						c.beginPath();
						c.arc(x * 90 + 47, y * 90 + 47, animationStage * 400, 0, Math.PI * 2, false);
						c.fillStyle = '#F88';
						c.fill();
					}
					if (tile & TILE_WATER){
						c.beginPath();
						c.fillStyle = '#88F';
						c.fillRect(x * 90 + 47 - animationStage * 1e3, y * 90 + 7, animationStage * 2e3, 80);
					}
					if (tile & TILE_AIR){
						c.beginPath();
						c.fillStyle = '#88F';
						c.fillRect(x * 90 + 7, y * 90 + 47 - animationStage * 1e3, 80, animationStage * 2e3);
					}

					x += Math.sin(i + animationStage * 79) * .05 * animationStage;
					y += Math.cos(i + animationStage * 69) * .05 * animationStage;
				}

				c.globalAlpha = 1 - animationStage;
				c.drawImage(hoveredTiles[descriptor.field[idx]], x * 90 + 7, y * 90 + 7);
				c.globalCompositeOperation = 'source-atop';

				if (descriptor.destructionStyle[idx] == 0){
					c.globalAlpha = animationStage;
					c.fillStyle = '#0B0';
					c.fillRect(x * 90 + 7, y * 90 + 7, 80, 80);
				}

				c.restore();
			}
		}
		return 1;
	}
}

function animationScore(descriptor){
	var animationStage = (new Date - descriptor.timestamp - 400) / 600;
	if (animationStage < 0){
		return 1;
	}
	if (animationStage < 1){
		c.save();
		c.textAlign = 'center';
		c.fillStyle = '#FFFFFF';
		var x = descriptor.idx % 8;
		var y = descriptor.idx / 8 | 0;
		c.translate(x * 90 + 47, y * 90 + 57 - animationStage*50);
		c.globalAlpha = Math.min(2 - animationStage * 2, 1);
		var scale = Math.log(descriptor.increment) * Math.cos(animationStage);
		c.scale(scale, scale);
		c.fillText(descriptor.increment, 0, 0);
		c.restore();
		return 1;
	}
}

function sweep(){
	console.log('sweep');
	var triples = [];
	// Pass 1: Find triples
	for (var i=8-2; i--; ){
		for (var j=8; j--; ){
			var idx = j * 8 + i;
			if (field[idx] && field[idx] == field[idx+1] && field[idx] == field[idx+2]){
				triples.push([idx, idx+1, idx+2])
			}
			var idx = i * 8 + j;
			if (field[idx] && field[idx] == field[idx+8] && field[idx] == field[idx+16]){
				triples.push([idx, idx+8, idx+16])
			}
		}
	}
	// Pass 2: Glue triples
	l:for (var i=triples.length; i--; ){
		for (var j=i; j--; ){
			for (var k=0; k < triples[i].length; k++){ // This loop is not reversed, as triples[i].length may change
				if (~triples[j].indexOf(triples[i][k])){
					triples[j] = triples[j].concat(triples[i]); // merge intersecting triples
					continue l; // there's no need to clean array
				}
			}
		}
		// Pass 3: Unique
		var triple = triples[i].sort(function(a,b){
			// Oh, this default javascript sort...
			return a-b;
		}); // .sort() is to be predictable

		var animation = {
			'fn': animationDisappear,
			'timestamp': +new Date,
			'tile': field[triple[0]]
		}

		for (var j=triple.length; j--; ){
			if (field[triple[j]]){
				// Change field
				field[triple[j]] = 0;
			} else {
				triple.splice(j, 1);
			}
		}
		animation.affectedTiles = triple;
		animation.q = getQTile(triple);
		if (animation.q){ // Not -1 or undefined
			field[animation.q] = 16; // Quintessence
		}
		blockingAnimations.push(animation);

		// Main tile cannot be equal 0. Supposedly.
		addScore(100 * 1 << (triple.length - 2), animation.q || triple[1]);
	}
}

// Get "main" tile from adjacent ones
function getQTile(triple){
	for (var i=5; i--; ){
		for (var j=8; j--; ){
			var flag = 1;
			var idx = i + j * 8;
			for (var k=5; k--; ){
				flag  = flag && ~triple.indexOf(idx + k);
			}
			if (flag){
				return idx + 2;
			}
			var flag = 1;
			var idx = i * 8 + j;
			for (var k=5; k--; ){
				flag  = flag && ~triple.indexOf(idx + k * 8);
			}
			if (flag){
				return idx + 16;
			}
		}
	}
}

function gravity(){
	console.log('gravity');
	var offscreenStack = []; // Tiles that are falling offscreen
	for (var i = 64; i--;){ // Lower 7 rows
		if (!field[i]){ // Field is empty
			for (var j=i; j>=0; j-=8){
				if (field[j]){ // Tile found on board
					field[i] = field[j]; // Move tile
					field[j] = 0;
					var fallFrom = j / 8 | 0;
					break;
				}
			}
			if (!field[i]){ // No tiles was found that can fall
				field[i] = getNewTileIndex(); // Create new tile
				var column = i % 8;
				fallFrom = (offscreenStack[column] = ~-offscreenStack[column]) * 1.5 + Math.random()*.25; // Decide from what position it would fall
			}
			blockingAnimations.push({
				'fn': animationFalling, // Type of animation
				'affectedTiles': [i], // Tiles that are affected (always an array)
				'timestamp': +new Date, // Start of the animation
				'fallFrom': fallFrom // custom for "gravity" - where tile is fall from
			});
		}
	}
}

function explosion(){
	// There can be only one explosive tile on a board. At least, it is supposed so.
	for (var i=64; i--;){
		var explosiveTile = field[i];
		if (explosiveTile > 16){
			var destructionStyle = {};
			var affectedTiles = [i];
			blockingAnimations.push({
				'fn': animationExplosion,
				'affectedTiles': affectedTiles, // Will be filled later, store by reference
				'timestamp': +new Date,
				'field': field.slice(), // Copy of the entire field
				'destructionStyle': destructionStyle
			});

			if (explosiveTile == 31){
				for (var j=64; j--; ){
					field[j] = 0;
					affectedTiles.push(j);
				}
			} else {
				field[i] = 0;
				if (explosiveTile & TILE_EARTH){ // Earth: 8 random tiles
					for (var j=8; j;){ // WARNING: No guard from infinite loop. If there's no enough tiles on the board, everything will hang
						var idx = Math.random() * 64 | 0; // Get completely random index
						if (!destructionStyle[idx] && field[idx]){
							// If tile exists on filed, not the Q-earth tile itself, and not yet picked
							destructionStyle[idx] = 0;
							j--;
						};
					}
				}
				if (explosiveTile & TILE_FIRE){ // Fire: 8 nearest tiles
					for (var j=2;~j--;){ // Not the loop you can see every day. 1..-1
						for (var k=2;~k--;){
							var idx = i + j * 8 + k;
							if (~(i % 8 + k) & 8 && field[idx]){ // x != -1 and  x != 8 and within board
								destructionStyle[idx] = 3;
							}
						}
					}
				}
				for (var j=64; j--; ){ // Water / Air: Row / Column
					if (j >> 3 == i >> 3 && field[j] && explosiveTile & TILE_WATER){
						destructionStyle[j] = 1;
					}
					if (j % 8 == i % 8 && field[j] && explosiveTile & TILE_AIR){
						destructionStyle[j] = 2;
					}
				}
				for (j in destructionStyle){
					affectedTiles.push(+j);
					field[j] = 0;
				}
			}
		}
	}
}

function draw(){
	console.log('draw');
	a.width=724;
	// Get tiles that are blocked by animations
	var blockedTiles = [];
	for (var i=blockingAnimations.length; i--; ){ // All the blocking animations happens in the same time
		var animation = blockingAnimations[i];
		if (animation.fn(animation)){
			// Animation returned true. We don't need to draw affeted tiles
			blockedTiles = blockedTiles.concat(animation.affectedTiles || []);
		} else {
			// Animation is ended or expired
			blockingAnimations.splice(i, 1);
		}
	}

	for (var i=nonblockingAnimations.length; i--; ){
		var animation = nonblockingAnimations[i];
		var tilesBlocked = 0;
		for (var j=animation.affectedTiles.length; j--; ){
			if (~blockedTiles.indexOf(animation.affectedTiles[j])){
				tilesBlocked = 1;
			}
		}
		if (!tilesBlocked && animation.fn(animation)){
			blockedTiles = blockedTiles.concat(animation.affectedTiles || []);
		} else {
			nonblockingAnimations.splice(i, 1);
		}
	}

	c.save();
	c.globalCompositeOperation = 'destination-over'; // Draw all ordinary tiles below
	// Draw not blocked tiles
	for (var i=64; i--; ){
		if (!~blockedTiles.indexOf(i) && field[i]){
			var x = i % 8;
			var y = i / 8 | 0;
			// Highlight current cell only if no animations
			var imageArray = (!blockingAnimations[0] && i==(dragStartCoords||hoveredCoords)[4])?hoveredTiles:tiles;
			c.drawImage(imageArray[field[i]], x * 90 + 7, y * 90 + 7);
		}
	}
	c.restore(); // undo destination-over
}

var recalcState = [];
var animationFrameRequested = 0;

function invalidate(){
	if (!animationFrameRequested){
		requestAnimationFrame(onFrame);
		animationFrameRequested = 1;
	}
}

function onFrame(){
	/**
I will explain everything!

This is a state machine which is evaluated on each requested frame.

First of all, if there's any running blocking animations, draw frame and request next.

If there's no running blocking animations, and there's an array `recalcState`, then recalculate the field:
- find triples and destroy it;
- do gravity.

Each action changes field state to the final and registers blocking animation.
Only one action is produced at once. Otherwise field may change dramatically and we'll paint nonsence.
These actions are in the loop that finishes if neither gravity, nor sweep made nothing.
	**/

	animationFrameRequested = 0;
	for (;recalcState && !blockingAnimations.length;){
		[explosion, sweep, gravity][recalcState.length % 3]();
		recalcState.push(blockingAnimations.length);
		if (recalcState.slice(-3) == '0,0,0'){ // All the recalc functions did nothing
			recalcState = 0; // something falsy
		}
	}
	if (blockingAnimations[0] || nonblockingAnimations[0]){
		invalidate(); // Paint next frame until there are animations
	}
	draw();
}

invalidate();


</script>

