<!DOCTYPE html>
<link id=l>
<title>Quintessence</title>
<body bgcolor=#333638>
<meta name="viewport" content="width=device-width,height=device-height,initial-scale=1,maximum-scale=1,user-scalable=no">
<div id=w>
<center id=m></center>
<div style="padding:10px;height:16px">Score <b id=s>0</b></div>
<canvas id="a"></canvas>
</div>
<script>
function mainMenu(){
	m.style.display = 'block';
	m.innerHTML = '<h1>Quintessence</h1><br><a onclick=start()>Start';
	// Add continue button
	if ((self.localStorage||{})['Quintessence.save']){
		m.innerHTML += '<a onclick=load()>Continue';
	} else {
		m.innerHTML += '<a>Continue';
	}
	m.innerHTML += '<a onclick=startDemo()>How to play'
}

mainMenu();

var scaledSize;
var scaledTop;
var scaledLeft;

function resize(){
	var contentWidth = 724;
	var contentHeight = 760;
	var viewportWidth = document.documentElement.clientWidth;
	var viewportHeight = document.documentElement.clientHeight;
	scale = Math.min(viewportWidth / contentWidth, viewportHeight / contentHeight);
	if (scale > 1){
		// Upscale only by multipliers of two
		scale = (scale << 1) >> 1;
	}
	if (
		!['transform', '-webkit-transform', '-moz-transform', '-o-transfrom', '-ms-transform'].some(function(k){
			if (k in w.style){
				w.style[k+'-origin'] = '362px 0';
				return w.style[k] = scale ^ 1 ? 'scale(' + scale + ')' : '';
			}
		})
	){
		scale = 1;
		// Fall back. CSS tranform is not supported
	}
	scaledSize = contentWidth * scale;
	scaledTop = 36 * scale; // Score div height
	scaledLeft = (viewportWidth - scaledSize) / 2;
}

resize();
window.onresize = resize;

// Tiles
var titles = [
	,               // Binary 00000
	"Earth",        // Binary 00001
	"Water",        // Binary 00010
	"Mud",          // Binary 00011
	"Air",          // Binary 00100
	"Sand",         // Binary 00101
	"Rain",         // Binary 00110
	"Golem",        // Binary 00111
	"Fire",         // Binary 01000
	"Brimstone",    // Binary 01001
	"Alcohol",      // Binary 01010
	"Oil",          // Binary 01011
	"Phlogiston",   // Binary 01100
	"Diamond",      // Binary 01101
	"Lightning",    // Binary 01110
	"Life",         // Binary 01111
	"Quintessence", // Binary 10000
	,,,,,,,,,,,,,,  // Bunch of explosive elements that has no title
	"Harmony"       // Binary 11111
];


// var TILE_EARTH = parseInt('00001', 2);
// var TILE_WATER = parseInt('00010', 2);
// var TILE_AIR   = parseInt('00100', 2);
// var TILE_FIRE  = parseInt('01000', 2);
// var TILE_QUINTESSENCE = parseInt('10000', 2);

var tiles = []; // Tile images
var hoveredTiles = []; // Tile images

var c=a.getContext('2d');

for (var code=64; code--; ){
	a.width=80;
	a.height=80;
	var imageData=c.createImageData(80,80);
	for (var idx=6400; idx--; ){
		var y = (idx / 80 | 0) - 39.5;
		var x = idx % 80 - 39.5;

		var value = Math.random() * 16 | 160; // 0xA0...0xAF integer
		value -= (x*x*x)/1200;
		value -= (y*y*y)/1200;

		imageData.data[idx*4] = value + (code == 8 /* TILE_FIRE */ || code == 4 /* TILE_AIR */) * 20;
		imageData.data[idx*4+1] = value - 5 + (code == 1 /* TILE_EARTH */ || code == 4 /* TILE_AIR */) * 20;
		imageData.data[idx*4+2] = value - 20 + (code == 2 /* TILE_WATER */) * 20;
		imageData.data[idx*4+3] = 9000 - (x*x+y*y)*3;
	}
	for (var activityState = 2; activityState--; ){
		c.putImageData(imageData, 0, 0);

		c.globalCompositeOperation = 'source-atop';
		for (var drawPosition = 6; --drawPosition;){ // Note the pre-increment. drawPosition is in range 5..1
			c.save();

			c.translate(
				drawPosition & 4 && (5 - drawPosition) * 2 - 1,
				drawPosition & 2 && (3 - drawPosition) * 2 - 1
			);

			c.strokeStyle = c.fillStyle = drawPosition & 1 ? '#000' : '#FFF';
			c.globalAlpha = drawPosition ^ 1 ? 0.3 : activityState || .7;

			c.textAlign = 'center';
			c.fillText([titles[code]], 40, 70);

			if (activityState && drawPosition == 1){
				c.strokeStyle = '#CCC';
			}

			// Draw icons
			c.beginPath();
			c.lineWidth = 2;
			if (code == 1){ // Earth
				c.moveTo(17, 31);
				c.bezierCurveTo(
					22, 24,
					32, 24,
					32, 31
				);
				c.bezierCurveTo(
					33, 21,
					47, 21,
					49, 31
				);
				c.bezierCurveTo(
					51, 28,
					56, 24,
					63, 31
				);
				c.moveTo(18, 39);
				c.lineTo(62, 39);
				c.moveTo(18, 48);
				c.lineTo(62, 48);
			}
			if (code == 2){ // Water
				c.moveTo(20, 45);
				c.bezierCurveTo(
					40, 60,
					40, 30,
					60, 45
				);
				c.moveTo(20, 35);
				c.bezierCurveTo(
					40, 50,
					40, 20,
					60, 35
				);
				c.moveTo(20, 25);
				c.bezierCurveTo(
					40, 40,
					40, 10,
					60, 25
				);
			}
			if (code == 3) { // Mud
				c.moveTo(26, 40);
				c.bezierCurveTo(
					11, 40,
					16, 55,
					46, 45
				);
				c.bezierCurveTo(
					66, 45,
					66, 40,
					56, 40
				);
				c.moveTo(53, 35);
				c.arc(49, 35, 4, 0, Math.PI * 2, false);
				c.moveTo(40, 30);
				c.arc(33, 30, 7, 0, Math.PI * 2, false)
			}
			if (code == 4) { // Air
				c.moveTo(20, 35);
				c.bezierCurveTo(
					20, 32,
					60, 38,
					60, 35
				);
				c.moveTo(20, 27);
				c.bezierCurveTo(
					60, 27,
					65, 17,
					50, 17
				);
				c.moveTo(20, 43);
				c.bezierCurveTo(
					60, 43,
					65, 53,
					50, 53
				);
			}
			if (code == 5){ // Sand
				c.moveTo(20, 50);

				c.bezierCurveTo(
					35, 10,
					35, 10,
					50, 50
				);

				c.bezierCurveTo(
					50, 50,
					50, 55,
					35, 55
				);

				c.moveTo(50, 35);
				c.bezierCurveTo(
					55, 25,
					65, 50,
					65, 50
				);
			}
			if (code == 6){ // Rain
				c.moveTo(32, 25);
				c.bezierCurveTo(
					20, 20,
					15, 38,
					20, 38
				);
				c.lineTo(60, 38);
				c.bezierCurveTo(
					65, 38,
					63, 8,
					45, 19
				);
				c.moveTo(48, 27);
				c.bezierCurveTo(
					48, 17,
					32, 23,
					32, 30
				);
				c.moveTo(32, 42);
				c.lineTo(28, 51);

				c.moveTo(42, 42);
				c.lineTo(37, 53);

				c.moveTo(52, 42);
				c.lineTo(48, 51);

			}
			if (code == 7) { // Golem
				c.moveTo(20, 55);
				c.bezierCurveTo(
					20, 35,
					25, 40,
					30, 35
				);
				c.bezierCurveTo(
					38, 30,
					25, 20,
					40, 20
				);

				c.bezierCurveTo(
					55, 20,
					42, 30,
					50, 35
				);
				c.bezierCurveTo(
					55, 40,
					60, 35,
					60, 55
				);

				c.moveTo(31, 55);
				c.bezierCurveTo(
					31, 45,
					28, 46,
					27, 46
				);

				c.moveTo(49, 55);
				c.bezierCurveTo(
					49, 45,
					52, 46,
					53, 46
				);
			}
			if (code == 8){ // Fire
				c.moveTo(25, 40);
				c.bezierCurveTo(
					25, 60,
					55, 60,
					55, 40
				);
				c.bezierCurveTo(
					55, 30,
					40, 25,
					40, 15
				);
				c.bezierCurveTo(
					30, 25,
					45, 40,
					40, 40
				);
			}
			if (code == 9){ // Sulfur/Brimstone
				c.moveTo(33, 23);
				c.lineTo(42, 27);
				c.lineTo(45, 58);
				c.lineTo(20, 43);
				c.lineTo(30, 20);
				c.lineTo(42, 14);
				c.lineTo(55, 20);
				c.lineTo(68, 47);
				c.lineTo(50, 55);
			}
			if (code == 10){ // Alcohol
				c.moveTo(32, 17);
				c.bezierCurveTo(
					38, 17,
					37, 17,
					37, 35
				);
				c.bezierCurveTo(
					20, 47,
					15, 52,
					40, 52
				);
				c.bezierCurveTo(
					65, 52,
					60, 47,
					43, 35
				);
				c.bezierCurveTo(
					43, 17,
					42, 17,
					48, 17
				)
			}
			if (code == 11){ // Oil. Barrel of oil, or lantern - pick yourself
				c.moveTo(25, 18);
				c.bezierCurveTo(
					25, 10,
					55, 10,
					55, 18
				);
				c.bezierCurveTo(
					55, 26,
					25, 26,
					25, 18
				);
				c.moveTo(55, 48);
				c.bezierCurveTo(
					55, 56,
					25, 56,
					25, 48
				);
				c.moveTo(27, 47);
				c.lineTo(27, 24);
				c.moveTo(53, 47);
				c.lineTo(53, 24);

				c.moveTo(40, 30);
				c.bezierCurveTo(
					30, 50,
					50, 50,
					40, 30
				);
			}
			if (code == 12){ // Phlogiston
				c.moveTo(37, 10);
				c.bezierCurveTo(
					47, 20,
					17, 35,
					37, 45
				)
				c.moveTo(43, 54);
				c.bezierCurveTo(
					33, 44,
					63, 29,
					43, 19
				)
			}
			if (code == 13){ // Diamond
				c.moveTo(48, 30);
				c.lineTo(32, 30);
				c.lineTo(20, 27);
				c.lineTo(30, 17);
				c.lineTo(50, 17);
				c.lineTo(60, 27);
				c.lineTo(40, 52);
				c.lineTo(23, 32);
			}
			if (code == 14){ // Lightning
				c.moveTo(35, 13);
				c.lineTo(30, 33);
				c.lineTo(40, 35);
				c.lineTo(31, 51);
				c.lineTo(55, 31);
				c.lineTo(42, 28);
				c.lineTo(50, 15);
				c.lineTo(40, 14);
			}
			if (code == 15) { // Life
				c.moveTo(43, 19);
				c.bezierCurveTo(
					48, 13,
					55, 13,
					60, 18
				);
				c.bezierCurveTo(
					75, 33,
					40, 53,
					40, 53
				);
				c.bezierCurveTo(
					40, 53,
					5, 33,
					20, 18
				);
				c.bezierCurveTo(
					40, 8,
					45, 31,
					45, 35
				);
			}
			if (code == 16) { // Quintessence
				c.arc(40, 40, 23, 2.5, 6.9, false);
			}

			c.stroke();


			// Draw elelment hints
			if (code & 16){
				c.beginPath();
				c.arc(40, 40, 8, 0, Math.PI * 2, false);
				if (drawPosition == 1 && code != 31){
					c.fillStyle = '#FFF';
				}
				c.fill();
			}

			for (var bit = 4; bit--; ){
				// Draw special Q tiles
				c.beginPath();
				if (code > 16 && code < 31){
					if (bit & 1 ? code & 4 /* TILE_AIR */ : code & 2 /* TILE_WATER */){
						c.moveTo(40, 8);
						c.bezierCurveTo(
							48, 33,
							32, 33,
							40, 8
						);
					}
					if (code & 8 /* TILE_FIRE */) {
						c.moveTo(25, 25);
						c.bezierCurveTo(
							25, 40,
							40, 30,
							25, 25
						);
					}
					if (code & 1 /* TILE_EARTH */){
						c.moveTo(11, 31);
						c.bezierCurveTo(
							7, 27,
							27, 7,
							31, 11
						);
						c.lineTo(11, 31)
					}
				}
				c.stroke();

				if (code & (1<<bit)){
					c.beginPath();
					c.moveTo(0,0);
					c.lineTo(0,35);
					c.bezierCurveTo(10,35,-4,5,12,12);
					c.bezierCurveTo(5,-4,35,10,35,0);
					if (drawPosition == 1 && code != 31){
						c.fillStyle = ['#0B0', '#00C', '#DD0', '#C00'][bit];
					}
					c.fill();
				}
				c.translate(40, 40);
				c.rotate(Math.PI / 2);
				c.translate(-40, -40);
			}
			c.restore();
		}
		var image = new Image();
		image.src = a.toDataURL();
		if (activityState){
			hoveredTiles[code] = image;
		} else {
			if (code == 16){ // Favicon
				l.href = image.src;
				l.rel = 'shortcut icon';
			}
			tiles[code] = image;
		}
	}
}

// Draw bg
a.width=724;
a.height=724;
var TILE_WIDTH = 80;
var CELL_PADDING = 2;
var CELL_BORDER = 1;
var CELL_MARGIN = 4;
var cell = CELL_PADDING + TILE_WIDTH + CELL_PADDING;
var cellInterval = CELL_BORDER + cell + CELL_BORDER + CELL_MARGIN;

var size = 8 * (CELL_BORDER + cell + CELL_BORDER) + (8+1) * CELL_MARGIN;

var imageData=c.createImageData(size,size);
for (var idx=size * size; idx--; ){
	var xPhase = idx % size % cellInterval - CELL_MARGIN;
	var yPhase = (idx / size % cellInterval | 0) - CELL_MARGIN;
	 // Board acts like background, it should be darker and more bluish
	var value = Math.random() * 12 | 96; // 0x60...0x6B integer

	if (xPhase >= 0 & yPhase >= 0){
		value -= 20;
		if (xPhase == 0 || yPhase == 0){
			value -= 30;
		}
		if (xPhase == CELL_BORDER + cell || yPhase == CELL_BORDER + cell){
			value += 30;
		}
	}

	imageData.data[idx*4] = value;
	imageData.data[idx*4+1] = value+=3;
	imageData.data[idx*4+2] = value+=5;
	imageData.data[idx*4+3] = 255;
}
c.putImageData(imageData, 0, 0);

a.style.background = 'url(' + a.toDataURL() + ')'; // We don't need to repaint this

// Sound
var sounds = [];

for(var t=0, S=atob('UklGRoTqAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YWDqAAA=');t++<30000;){
	for (var v=0, h = 9; --h; ){
		v += Math.sin(t / 15 / h) // Sine wave
			* Math.cos(h) * h * h // Harmonics
			* 300 // Volume
			* (60000 / (30000 + t) - 1) // Decay
		;
	}
	S+=String.fromCharCode(v & 255, (v >>> 8 ) & 255);
}
sounds.push('data:audio/wav;base64,' + btoa(S));

// Merge
for(var t=0, S=atob('UklGRoTqAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YWDqAAA=');t++<30000;){
	for (var v=0, h = 9; --h; ){
		v += Math.sin(t / 25 / h) * Math.sin(h/2) * 6000 * (60000 / (30000 + t) - 1);
	}
	S+=String.fromCharCode(v & 255, (v >>> 8 ) & 255);
}
sounds.push('data:audio/wav;base64,' + btoa(S));

// Triple
for(var t=0, S=atob('UklGRoTqAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YWDqAAA=');t++<30000;){
	for (var v=0, h = 9; --h; ){
		v += Math.sin(t / 15 / h) * Math.cos(h) * 7000 * (60000 / (30000 + t) - 1);
	}
	S+=String.fromCharCode(v & 255, (v >>> 8 ) & 255);
}
sounds.push('data:audio/wav;base64,' + btoa(S));

// Falling end
for(var t=0, S=atob('UklGRoTqAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YWDqAAA=');t++<30000;){
	for (var v=0, h = 9; --h; ){
		v += Math.sin(t / 180 * h) // Sine wave
			* Math.sin(h) / h // Harmonics
			* 10 // Volume
			* (30050 / (t + 50)) // Decay
		;
	}
	S+=String.fromCharCode(v & 255, (v >>> 8 ) & 255);
}
sounds.push('data:audio/wav;base64,' + btoa(S));
////

function playSound(i){
	var audio = document.createElement('audio');
	audio.autoplay = true;
	audio.src = sounds[i];
}


function getNewTileIndex(){
	// We have two tile generation algos
	// Until player gets a 100K score only basic elements appears
	// When player gets 1M score probability of all elements are equal
	// Between these scores probability gradually increases
	if (Math.random() > (score - 100000) / 900000){
		// Only basic elements
		return [1,2,4,8][Math.random() * 4 | 0];
	} else {
		// All non-q elements except life, 1..14
		return 1 + Math.random() * 14 | 0;
	}
}

var blockingAnimations = []; // Anything, just to ensure field filling loop works for the first time
var nonblockingAnimations = [];

var score = 0;

function getTileGeneration(tile){
	return tile.toString(2).replace(/0/g,'').length;
}

function addScore(increment, idx){
	if (!demoScenario){
		score += increment;
		s.innerHTML = score;
		nonblockingAnimations.push({
			'fn': animationScore,
			'affectedTiles': [],
			'timestamp': +new Date,
			'increment': increment,
			'idx': idx
		});
	}
}

var cascade = 0;
var uiLocked = 1;
var gameover = 1;
var field = [];
var demoScenario = 0;
var shiftScenario = 0;

function start(){ // or restart
	field = [];
	// Fill field ensuring there's no triples
	do { // repeat until there's no blocking animations (sweep/gravity did nothing)
		for (var i=64; i--; ){
			// Push random tiles
			field[i] = field[i] & 15 || getNewTileIndex();
		}

		// Cleanup all animations
		blockingAnimations = [];
		nonblockingAnimations = [];
		s.innerHTML = score = 0;
		// Fast forward sweep/gravity
		sweep();
	} while (blockingAnimations.length);
	gameover = 0;
	demoScenario = 0;
	uiLocked = 0;
	m.style.display = 'none';
	for (var i=64; i--; ){
		blockingAnimations.push({
			'fn': animationFalling, // Type of animation
			'affectedTiles': [i], // Tiles that are affected (always an array)
			'timestamp': +new Date, // Start of the animation
			'soundPlayed': 1,
			'fallFrom': -1, // custom for "gravity" - where tile is fall from
		});
	}
	animationFallingSound = 1;
	save();
	invalidate();
}

function load(){
	// I know, it consumes many bytes. But save state is sacred
	try {
		var saved = JSON.parse(localStorage['Quintessence.save']);
		field = saved.f.map(Number); // Make sure it's an array of numbers
		s.innerHTML = score = +saved.s; // Restore score
		gameover = 0; // Clear game over flag. It will be set on nxt invalidation if needed.
		m.style.display = 'none'; // Hide message
		demoScenario = 0;
		recalcState = []; // Init recalc
		invalidate(); // Request next frame
	} catch (e){
		alert('Save state is corrupted');
		start();
	}
}

function save(){
	if (!demoScenario){
		console.log('save to localStorage');
		(self.localStorage||{})['Quintessence.save'] = JSON.stringify({
			'f': field,
			's': score
		});
	}
	// Yes, you can cheat here.
}

function startDemo(){
	demoScenario = [
		{
			'text': "This game is all about merging elements.<br/>Drag any of these two tiles with mouse (or finger on touch device) to merge into a new tile.",
			'newTiles': {59:1,51:2}
		},
		{
			'text': "Perfect! You got the idea. Now try once again.<br/>Notice that some tiles cannot be merged, as tile cannot contain more than one of each basic element.",
			'newTiles': {60:2,52:1}
		},
		{
			'text': "Three identical tiles in a row disappears.",
			'newTiles': {61:1,53:2}
		},
		{
			'newTiles': {}
		},
		{
			'text': 'Create five tiles in a row and get something special.',
			'newTiles': {58:12,59:12,60:4,61:12,62:12,52:8}
		},
		{
			'newTiles': {}
		},
		{
			'text': 'This is a Quintessence, the fifth element.<br>Merge it with other tile and see what happens.',
			'newTiles': {59:15,60:4}
		},
		{
			'newTiles': {}
		}
	];
	recalcState = [];
	gameover = 0;
	invalidate();
}

var hoveredCoords = 0; // Something falsy, but not null/undefined
var dragStartCoords = 0; // Something falsy, but not null/undefined

function extractCoords(e){
	e.preventDefault();
	e = e.touches ? e.touches[0] : e;
	var coords = [
		e.pageX - scaledLeft, // [0] - Relative X
		e.pageY - scaledTop,  // [1] - Relative Y
	];
	coords = coords.concat(coords.map(getTileByCoord)); // [2], [3] - tile X/Y
	coords[4] = coords[3]*8 + coords[2];
	return coords;
}

function getTileByCoord(coord){
	coord = (coord * 724 / scaledSize - 2) / 90;
	if (coord < 0 || coord >= 8) return;
	return coord | 0;
}

// UI
document.ontouchmove = document.onmousemove = function(e){
	var coords = extractCoords(e);
	// Request repaint only if hovered tile changed
	// Keep in mind, coords[4] may be `undefined`!
	hoveredCoords[4] == coords[4] || invalidate();
	hoveredCoords = coords;
	if (dragStartCoords && !blockingAnimations[0]){
		var dx = hoveredCoords[0] - dragStartCoords[0];
		var dy = hoveredCoords[1] - dragStartCoords[1];
		if (dx*dx + dy*dy > scaledSize * scaledSize / 100){ // Threshold
			var direction = +(dx/dy * dx/dy < 1); // 0 if x, 1 if y
			var sign = hoveredCoords[direction] - dragStartCoords[direction] > 0 ? 1 : -1
			var newTileCoord = dragStartCoords[2+direction] + sign;
			var failed = 0;
			if (newTileCoord & 8){ // == 0 or == 8
				failed = 1;
			}
			var idx = (direction ? newTileCoord : dragStartCoords[3]) * 8 + (direction ? dragStartCoords[2] : newTileCoord);
			if (field[idx] & field[dragStartCoords[4]] || !field[idx]){
				failed = 1;
			}
			console.log('Drag from', dragStartCoords[4], 'to', idx, 'failed: ', !!failed);

			if (failed){
				nonblockingAnimations.push({
					'fn': animationMergeFailed,
					'affectedTiles': [dragStartCoords[4]],
					'timestamp': +new Date,
					'direction': direction,
					'sign': sign
				});
			} else {
				blockingAnimations = [{
					'fn': animationMerge, // Type of animation
					'affectedTiles': [idx, dragStartCoords[4]], // Tiles that are affected (always an array). To, from
					'timestamp': +new Date, // Start of the animation
					'tiles': [field[idx], field[dragStartCoords[4]]]
				}];

				// Changing field!
				field[idx] = field[idx] | field[dragStartCoords[4]];
				field[dragStartCoords[4]] = 0;

				//
				recalcState = recalcState || [];

				addScore(getTileGeneration(field[idx]) * 10, idx);
				uiLocked = 1;
				shiftScenario = 1;

				save();
			}
			invalidate();
			dragStartCoords = 0;
		}
	}
}
document.onmouseout = function(e){ // e argument is unused
	hoveredCoords = 0;
	invalidate();
}
document.ontouchstart = document.onmousedown = function(e){
	console.log(e);
	if (!uiLocked){
		var coords = extractCoords(e);
		dragStartCoords[4] == coords[4] || invalidate();
		dragStartCoords = field[coords[4]] && coords; // Do not start drag of empty tile
	}
}
document.ontouchend = document.onmouseup = function(e){  // e argument is unused
	dragStartCoords = 0;
	invalidate();
}


var animationFallingSound = 1;

function animationFalling(descriptor){
	var x = descriptor.affectedTiles % 8; // Affected tiles array contains only one value, it is safe do do this trick
	var yStart = descriptor.fallFrom;
	var yEnd = descriptor.affectedTiles / 8 | 0;
	var timeElapsed = new Date - descriptor.timestamp;
	var y = (timeElapsed * timeElapsed) / 1e5 + yStart; // Tile moves with acceleration
	if (y < yEnd){
		c.drawImage(tiles[field[descriptor.affectedTiles]], x * 90 + 7, y * 90 + 7);
		return 1;
	}
	if (animationFallingSound){
		animationFallingSound = 0;
		playSound(3);
	}
}

function animationMerge(descriptor){
	var animationStage = (new Date - descriptor.timestamp) / 300;
	if (animationStage < 2){
		var dstX = (descriptor.affectedTiles[0] % 8);
		var dstY = (descriptor.affectedTiles[0] / 8 | 0);

		c.save();
		c.fillStyle = '#FFF';
		if (animationStage < 1){
			if (!descriptor.soundPlayed){
				descriptor.soundPlayed = 1;
				playSound(1);
			}

			var animationDistance = Math.cos(animationStage * Math.PI / 2)
			var dX = (descriptor.affectedTiles[1] % 8) - dstX;
			var dY = (descriptor.affectedTiles[1] / 8 | 0) - dstY;
			var srcX = dstX + dX * animationDistance;
			var srcY = dstY + dY * animationDistance;

			c.drawImage(hoveredTiles[descriptor.tiles[0]], dstX * 90 + 7, dstY * 90 + 7);
			c.drawImage(hoveredTiles[descriptor.tiles[1]], srcX * 90 + 7, srcY * 90 + 7);


			var leftX = Math.max(dstX, srcX) * 90 + 7;
			var topY = Math.max(dstY, srcY) * 90 + 7;
			var rightX = Math.min(dstX, srcX) * 90 + 7 + 80;
			var bottomY = Math.min(dstY, srcY) * 90 + 7 + 80;

			if (rightX > leftX && bottomY > topY){
				c.globalCompositeOperation = 'source-atop';
				c.fillRect(
					leftX,
					topY,
					rightX - leftX,
					bottomY - topY
				)
			}
		} else {
			c.drawImage(hoveredTiles[field[descriptor.affectedTiles[0]]], dstX * 90 + 7, dstY * 90 + 7);
			c.globalCompositeOperation = 'source-atop';
			c.globalAlpha = 2 - animationStage;
			c.fillRect(dstX * 90 + 7, dstY * 90 + 7, 80, 80);
		}
		c.restore();
		return 1;
	}
}

function animationMergeFailed(descriptor){
	console.log('animationMergeFailed', descriptor.direction, descriptor.sign)
	var animationStage = (new Date - descriptor.timestamp) / 1000;

	if (!descriptor.soundPlayed){
		descriptor.soundPlayed = 1;
		playSound(0);
	}

	if (animationStage < 1){
		var shift = Math.cos(animationStage * 15) * .18 * (1-animationStage);
		var x = descriptor.affectedTiles[0] % 8 + shift * descriptor.sign * (1 - descriptor.direction);
		var y = (descriptor.affectedTiles[0] / 8 | 0) + shift * descriptor.sign * descriptor.direction;
		var tilesArray = descriptor.affectedTiles[0] == hoveredCoords[4] ? hoveredTiles : tiles;
		c.drawImage(tilesArray[field[descriptor.affectedTiles[0]]], x * 90 + 7, y * 90 + 7);
		return 1;
	}
}

var animationDisappearSound = 1;

function animationDisappear(descriptor){
	if (animationDisappearSound){
		animationDisappearSound = 0;
		playSound(2);
	}
	var alpha = 1 - (new Date - descriptor.timestamp) / 300;
	if (alpha > 0){
		if (descriptor.q){
			var x = descriptor.q % 8;
			var y = descriptor.q / 8 | 0;
			c.drawImage(hoveredTiles[16], x * 90 + 7, y * 90 + 7);
		}
		c.save();
		c.globalAlpha = alpha;
		for (var i=descriptor.affectedTiles.length; i--; ){
			var x = descriptor.affectedTiles[i] % 8;
			var y = descriptor.affectedTiles[i] / 8 | 0;
			c.drawImage(hoveredTiles[descriptor.tile], x * 90 + 7, y * 90 + 7);
		}
		c.restore();
		return 1;
	}
}

function animationExplosion(descriptor){
	var animationStage = (new Date - descriptor.timestamp) / 1000;
	if (animationStage < 1){
		var tile = descriptor.field[descriptor.affectedTiles[0]];
		if (tile == 31){
			var idx = descriptor.affectedTiles[0];
			var x = idx % 8;
			var y = idx / 8 | 0;
			c.save();
			c.globalAlpha = 1 - animationStage;
			c.fillStyle = '#FFF';
			c.fillRect(0,0,1e3,1e3);
			c.globalAlpha = Math.min((1 - animationStage) * 2, 1);
			c.drawImage(hoveredTiles[descriptor.field[idx]], x * 90 + 7, y * 90 + 7);
			c.restore();
		} else {
			for (var i=descriptor.affectedTiles.length; i--; ){
				c.save();
				var idx = descriptor.affectedTiles[i];
				var x = idx % 8;
				var y = idx / 8 | 0;
				if (!i){
					c.globalAlpha = Math.max((.7 - animationStage) * .7, 0);
					if (tile & 8 /* TILE_FIRE */){
						c.beginPath();
						c.arc(x * 90 + 47, y * 90 + 47, animationStage * 400, 0, Math.PI * 2, false);
						c.fillStyle = '#F88';
						c.fill();
					}
					if (tile & 2 /* TILE_WATER */){
						c.beginPath();
						c.fillStyle = '#88F';
						c.fillRect(x * 90 + 47 - animationStage * 1e3, y * 90 + 7, animationStage * 2e3, 80);
					}
					if (tile & 4 /* TILE_AIR */){
						c.beginPath();
						c.fillStyle = '#FF0';
						c.fillRect(x * 90 + 7, y * 90 + 47 - animationStage * 1e3, 80, animationStage * 2e3);
					}

					x += Math.sin(i + animationStage * 79) * .05 * animationStage;
					y += Math.cos(i + animationStage * 69) * .05 * animationStage;
				}

				c.globalAlpha = 1 - animationStage;
				c.drawImage(hoveredTiles[descriptor.field[idx]], x * 90 + 7, y * 90 + 7);
				c.globalCompositeOperation = 'source-atop';

				if (descriptor.destructionStyle[idx] == 0){
					c.globalAlpha = animationStage;
					c.fillStyle = '#0B0';
					c.fillRect(x * 90 + 7, y * 90 + 7, 80, 80);
				}

				c.restore();
			}
		}
		return 1;
	}
}

function animationScore(descriptor){
	var animationStage = (new Date - descriptor.timestamp - 400) / 600;
	if (animationStage < 0){
		return 1;
	}
	if (animationStage < 1){
		c.save();
		c.textAlign = 'center';
		c.fillStyle = '#FFFFFF';
		var x = descriptor.idx % 8;
		var y = descriptor.idx / 8 | 0;
		c.translate(x * 90 + 47, y * 90 + 57);
		c.globalAlpha = Math.min(2 - animationStage * 2, 1);
		var scale = Math.log(descriptor.increment) * Math.cos(animationStage / 2);
		c.scale(scale, scale);
		c.fillText(descriptor.increment, 0, -animationStage * 15);
		c.restore();
		return 1;
	}
}

function sweep(){
	cascade++;
	console.log('sweep, x' + cascade);
	var triples = [];
	// Pass 1: Find triples
	for (var i=8-2; i--; ){
		for (var j=8; j--; ){
			var idx = j * 8 + i;
			if (field[idx] && field[idx] == field[idx+1] && field[idx] == field[idx+2]){
				triples.push([idx, idx+1, idx+2])
			}
			var idx = i * 8 + j;
			if (field[idx] && field[idx] == field[idx+8] && field[idx] == field[idx+16]){
				triples.push([idx, idx+8, idx+16])
			}
		}
	}
	// Pass 2: Glue triples
	l:for (var i=triples.length; i--; ){
		for (var j=i; j--; ){
			for (var k=0; k < triples[i].length; k++){ // This loop is not reversed, as triples[i].length may change
				if (~triples[j].indexOf(triples[i][k])){
					triples[j] = triples[j].concat(triples[i]); // merge intersecting triples
					continue l; // there's no need to clean array
				}
			}
		}
		// Pass 3: Unique
		var triple = triples[i].sort(function(a,b){
			// Oh, this default javascript sort...
			return a-b;
		}); // .sort() is to be predictable

		var animation = {
			'fn': animationDisappear,
			'timestamp': +new Date,
			'tile': field[triple[0]]
		}

		for (var j=triple.length; j--; ){
			if (field[triple[j]]){
				// Change field
				field[triple[j]] = 0;
			} else {
				triple.splice(j, 1);
			}
		}
		animation.affectedTiles = triple;
		animation.q = getQTile(triple);
		if (animation.q){ // Not -1 or undefined
			field[animation.q] = 16; // Quintessence
		}
		blockingAnimations.push(animation);

		animationDisappearSound = 1; // One sound flag for all animations

		// Main tile cannot be equal 0. Supposedly.
		addScore(cascade * 100 * 1 << (triple.length - 2), animation.q || triple[1]);
		shiftScenario = 1;
	}

	if (!triples.length){
		cascade = 0;
	};
}

// Get "main" tile from adjacent ones
function getQTile(triple){
	for (var i=5; i--; ){
		for (var j=8; j--; ){
			var flag = 1;
			var idx = i + j * 8;
			for (var k=5; k--; ){
				flag  = flag && ~triple.indexOf(idx + k);
			}
			if (flag){
				return idx + 2;
			}
			var flag = 1;
			var idx = i * 8 + j;
			for (var k=5; k--; ){
				flag  = flag && ~triple.indexOf(idx + k * 8);
			}
			if (flag){
				return idx + 16;
			}
		}
	}
}

function gravity(){
	console.log('gravity');
	var offscreenStack = []; // Tiles that are falling offscreen
	for (var i = 64; i--;){ // Lower 7 rows
		if (!field[i]){ // Field is empty
			for (var j=i; j>=0; j-=8){
				if (field[j]){ // Tile found on board
					field[i] = field[j]; // Move tile
					field[j] = 0;
					var fallFrom = j / 8 | 0;
					break;
				}
			}
			if (!field[i]){ // No tiles was found that can fall
				if (demoScenario){
					if (demoScenario[0]){
						field[i] = field[i] || demoScenario[0].newTiles[i];
						delete demoScenario[0].newTiles[i]
					}
				} else {
					field[i] = getNewTileIndex(); // Create new tile
				}
				var column = i % 8;
				fallFrom = (offscreenStack[column] = ~-offscreenStack[column]) * 1.5 + Math.random()*.25; // Decide from what position it would fall
			}
			if (field[i]){
				blockingAnimations.push({
					'fn': animationFalling, // Type of animation
					'affectedTiles': [i], // Tiles that are affected (always an array)
					'timestamp': +new Date, // Start of the animation
					'fallFrom': fallFrom // custom for "gravity" - where tile is fall from
				});
				animationFallingSound = 1;
			}
		}
	}
}

function explosion(){
	// There can be only one explosive tile on a board. At least, it is supposed so.
	for (var i=64; i--;){
		var explosiveTile = field[i];
		if (explosiveTile > 16){
			var destructionStyle = {};
			var affectedTiles = [i];
			blockingAnimations.push({
				'fn': animationExplosion,
				'affectedTiles': affectedTiles, // Will be filled later, store by reference
				'timestamp': +new Date,
				'field': field.slice(), // Copy of the entire field
				'destructionStyle': destructionStyle
			});

			if (explosiveTile == 31){
				for (var j=64; j--; ){
					field[j] = 0;
					affectedTiles.push(j);
				}
			} else {
				field[i] = 0;
				if (explosiveTile & 1 /* TILE_EARTH */){ // Earth: 8 random tiles
					for (var j=8; j;){ // WARNING: No guard from infinite loop. If there's no enough tiles on the board, everything will hang
						var idx = Math.random() * 64 | 0; // Get completely random index
						if (!destructionStyle[idx] && field[idx]){
							// If tile exists on field, not the Q-earth tile itself, and not yet picked
							destructionStyle[idx] = 0;
							j--;
						};
					}
				}
				if (explosiveTile & 8 /* TILE_FIRE */){ // Fire: 8 nearest tiles
					for (var j=2;~j--;){ // Not the loop you can see every day. 1..-1
						for (var k=2;~k--;){
							var idx = i + j * 8 + k;
							if (~(i % 8 + k) & 8 && field[idx]){ // x != -1 and  x != 8 and within board
								destructionStyle[idx] = 3;
							}
						}
					}
				}
				for (var j=64; j--; ){ // Water / Air: Row / Column
					if (j >> 3 == i >> 3 && field[j] && explosiveTile & 2 /* TILE_WATER */){
						destructionStyle[j] = 1;
					}
					if (j % 8 == i % 8 && field[j] && explosiveTile & 4 /* TILE_AIR */){
						destructionStyle[j] = 2;
					}
				}
				for (j in destructionStyle){
					affectedTiles.push(+j);
					field[j] = 0;
				}
			}

			addScore(getTileGeneration(explosiveTile) * 100, i);
			shiftScenario = 1;
		}
	}
}

function movesLeft(){
	var moves = [];
	for (var i=8; i--; ){
		for (var j=7; j--; ){
			var idx = i * 8 + j;
			if (!(field[idx] & field[idx + 1])){
				moves.push([idx, 0]);
			}
			var idx = j * 8 + i;
			if (!(field[idx] & field[idx + 8])){
				moves.push([idx, 1]);
			}
		}
	}
	return moves;
}

function draw(){
	console.log('draw');
	a.width=724;
	// Get tiles that are blocked by animations
	var blockedTiles = [];
	for (var i=blockingAnimations.length; i--; ){ // All the blocking animations happens in the same time
		var animation = blockingAnimations[i];
		if (animation.fn(animation)){
			// Animation returned true. We don't need to draw affeted tiles
			blockedTiles = blockedTiles.concat(animation.affectedTiles || []);
		} else {
			// Animation is ended or expired
			blockingAnimations.splice(i, 1);
		}
	}

	for (var i=nonblockingAnimations.length; i--; ){
		var animation = nonblockingAnimations[i];
		var tilesBlocked = 0;
		for (var j=animation.affectedTiles.length; j--; ){
			if (~blockedTiles.indexOf(animation.affectedTiles[j])){
				tilesBlocked = 1;
			}
		}
		if (!tilesBlocked && animation.fn(animation)){
			blockedTiles = blockedTiles.concat(animation.affectedTiles || []);
		} else {
			nonblockingAnimations.splice(i, 1);
		}
	}

	c.save();
	c.globalCompositeOperation = 'destination-over'; // Draw all ordinary tiles below
	// Draw not blocked tiles
	for (var i=64; i--; ){
		if (!~blockedTiles.indexOf(i) && field[i]){
			var x = i % 8;
			var y = i / 8 | 0;
			// Highlight current cell only if UI not locked
			var imageArray = (!uiLocked && i==(dragStartCoords||hoveredCoords)[4])?hoveredTiles:tiles;
			c.drawImage(imageArray[field[i]], x * 90 + 7, y * 90 + 7);
		}
	}
	c.restore(); // undo destination-over
}

var recalcState = [];
var animationFrameRequested = 0;

function invalidate(){
	if (!animationFrameRequested && !gameover){
		// requestAnimationFrame or setTimeout - whichever is supported
		// 2nd arg to rAF is ignored
		(self.requestAnimationFrame || setTimeout)(onFrame, 33);
		animationFrameRequested = 1;
	}
}

function onFrame(){
	/**
I will explain everything!

This is a state machine which is evaluated on each requested frame.

First of all, if there's any running blocking animations, draw frame and request next.

If there's no running blocking animations, and there's an array `recalcState`, then recalculate the field:
- find triples and destroy it;
- do gravity.

Each action changes field state to the final and registers blocking animation.
Only one action is produced at once. Otherwise field may change dramatically and we'll paint nonsence.
These actions are in the loop that finishes if neither gravity, nor sweep made nothing.
	**/
	animationFrameRequested = 0;
	for (;recalcState && !blockingAnimations[0];){
		if (demoScenario){
			shiftScenario && demoScenario.shift();
			shiftScenario = 0;
			if (demoScenario[0]){
				if (demoScenario[0].text){
					m.innerHTML = demoScenario[0].text;
					delete demoScenario[0].text;
				}
			} else {
				setTimeout(mainMenu, 1000);
			}
		}
		uiLocked = 1;
		[explosion, sweep, gravity][recalcState.length % 3]();
		recalcState.push(blockingAnimations.length);
		if (recalcState.slice(-3) == '0,0,0'){ // All the recalc functions did nothing
			recalcState = 0; // something falsy
			uiLocked = 0;
			if (!movesLeft().length){
				// "Game over man, the end"
				m.innerHTML = '<h1>Game Over</h1><p>Your final score is<h3>' + score + '</h3><a target=_blank href="//twitter.com/intent/tweet?text=I scored '+ score +' in Quintessence, a %23js13k game.&url=' + location + '&hashtags=QuintessenceGame">Tweet my score<a onclick=start()>Start over';
				m.style.display = 'block';
				delete (self.localStorage||{})['Quintessence.save'];
				gameover = 1;
				uiLocked = 1;
			}
		}
		if (blockingAnimations[0]){
			save();
		}
	}
	if (blockingAnimations[0] || nonblockingAnimations[0]){
		invalidate(); // Paint next frame until there are animations
	}
	draw();
}

// start();
</script>
<style>
html,body{-ms-touch-action:none;overflow: hidden;width:100%;height:100%;margin:0;font:16px/20px sans-serif;color:#FFF;cursor:default}
#w{width:724px;height:760px;position:absolute;top:0;left:50%;margin:0 -362px}
#m{position:absolute;width:660px;top:99px;margin:12px;background:rgba(0,0,0,.7);padding:20px;border-radius:4px}
#a{display:block}
a{display:block;border:solid 1px;color:#aaa;padding:10px;width:150px;margin:9px}
a[onclick]{cursor:pointer;color:#fff;border-color:#fff}
a[onclick]:hover{background:#fff;color:#000}
:link{color:#55acee;border-color:#55acee;text-decoration:none}
:link:hover{background:#55acee;color:#fff}